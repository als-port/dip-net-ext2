Александр,

К организации инфраструктуры не имею никаких претензий. Что-то я бы сделал иначе, но ваш вариант работоспособен и заданию отвечает.

А вот по части CI/CD есть вопросы. В задании написано:

    Ожидаемый результат
    При любом коммите в репозиторий с тестовым приложением происходит сборка и отправка в регистр Docker образа.
    При создании тега в репозитории происходит деплой соответсвующего Docker образа.

То есть процесс я вижу следующим образом:

    Вы, как разработчик много и часто коммитите в репозиторий, для проверки правильности вашего коммита происходит сборка Docker-контейнера. Конечно, в настоящем CI этому будут предшествовать тесты, но будем считать, что факт сборки образа уже подтверждает правильность изменения. На этом этапе (запуск пайплайна по коммиту в main) пайплайн должен останавливаться на проверке (сразу после сборки образа). Можно отправить его в docker hub с тегом latest, чтобы разработчик имел возможность образ скачать к себе на компьютер и протестировать локально. Но в рамках дипломного проекта это не оязательно.
    Предположим, что локальное тестирование разработчика устроило, он считает, что текущий код в main хорош для релиза. Чтобы произвести релиз, разработчик создаёт тег в git (!) и отправляет его git push --tags. Тег имеет формат версии (например, 1.0.0). При появлении нового тега в git, Jenkins должен запустить другой пайплайн (или единственный пайплайн должен переключиться на другой режим). В этом пайплайне (запускающемся не по событию коммита, а по событию появления нового тега) следует сделать git checkout по имени этого тега, собрать образ, поставив его (образа) тег в значение равное имени тега в git. После этого его отправить в docker hub и запустить деплой именно этого (тегированного версией) образа в k8s. Если вы всё-таки не хотите использовать helm для такого деплоя (хотя сегодня это практически стандарт де-факто для индустрии), можете прямо в kube_app.yaml заменить тег ообраза на PLACEHOLDER и перед деплоем менять его, например, через sed: sed -i -e "s/PLACEHOLDER/${GIT_TAG}/" kube_app.yaml. Разумеется, переменную следует использовать правильную, ту, где у вас будет значение этого нового тега.

Пару слов о том, почему версионирование важно. В идеологии DevOps одним из важнейших условия является повторяемость: повторяемость процессов, повторяемость результатов. Если нет версионирования артефактов (в данном случае образов), то запустив деплой через неделю вы не получите тот же самый результат, что и неделю назад. А если после такого деплоя что-т оокажется сломанным, вы не сможете откатить приложение на предыдущую версию - обычно сборка приложения и образа занимает не секунды, как в вашем случае, а серьёзно больше времени, в это время приложение недоступно, бизнес теряет деньги. Наконец, если у вас есть стенд для тестирования, но нет версионирования, вы не можете перредать на “боевой” кластер именно нужный артефакт, который уже протестировали на стенде. Ведь у вас его просто нет, есть только последний.

Что касается выполнения. Предлагаю больше не создавать ресурсы в AWS, чтобы не тратить деньги, а запустить Jenkins локально. Мне будет достаточно почитать Jenkinsfile’ы, посомтреть скриншоты джоб. Кстати, рассмотрите плагин github для Jenkins: использование polling неэффективно, особенно для больших проектов, а плагин позволит настроить запуск пайплайнов по событиям. Впрочем, это остаётся на ваше усмотрение.

Надеюсь, мне удалось понятно объяснить, что именно я бы хотел увидеть в работе. Если остались ворпосы, можете написать мне в Slack.
